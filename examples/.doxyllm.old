PROJECT CONTEXT: C++20 std::span Implementation

This is a header-only implementation of C++20's std::span class, which provides a non-owning view over a contiguous sequence of elements. The implementation is designed to be compatible with C++11 and later standards while providing C++20 std::span functionality.

KEY CONCEPTS:
- span: A lightweight, non-owning view over contiguous memory
- dynamic_extent: Special constant indicating runtime-determined span size
- element_type: The type of elements the span views
- Extent: Compile-time size (or dynamic_extent for runtime size)

DESIGN PRINCIPLES:
- Zero-overhead abstraction: spans have no runtime cost over raw pointers
- Type safety: prevents common array access errors through bounds checking
- Flexibility: works with arrays, std::array, std::vector, and other containers
- Compatibility: provides C++20 functionality on older compilers

USAGE PATTERNS:
- Pass spans instead of raw pointers + size parameters
- Use span<const T> for read-only views
- Use dynamic_extent for runtime-sized spans
- Use fixed extents for compile-time sized spans

IMPLEMENTATION DETAILS:
- Uses SFINAE and type traits for proper overload resolution
- Includes custom constexpr macros for cross-compiler compatibility
- Provides contract checking via assertions (configurable)
- Contains helper functions for size(), data(), and container detection

The 'tcb' namespace wraps the entire implementation, with an 'mgl' namespace alias provided for convenience.
